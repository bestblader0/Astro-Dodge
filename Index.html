<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Astro Dodge</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background: radial-gradient(circle at center, #00111a, #000000);
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Mobile-friendly sizing
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let ship = { x: canvas.width / 2, y: canvas.height - 60, size: 30 };
    let asteroids = [];
    let score = 0;
    let gameOver = false;

    function drawShip() {
      ctx.fillStyle = "cyan";
      ctx.beginPath();
      ctx.moveTo(ship.x, ship.y - ship.size / 2);
      ctx.lineTo(ship.x - ship.size / 2, ship.y + ship.size / 2);
      ctx.lineTo(ship.x + ship.size / 2, ship.y + ship.size / 2);
      ctx.closePath();
      ctx.fill();
    }

    function drawAsteroids() {
      ctx.fillStyle = "red";
      for (let a of asteroids) {
        ctx.beginPath();
        ctx.arc(a.x, a.y, a.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function updateAsteroids() {
      for (let a of asteroids) {
        a.y += a.speed;
        if (a.y > canvas.height + a.size) {
          asteroids.splice(asteroids.indexOf(a), 1);
          score++;
        }
        // Collision detection
        if (
          a.x > ship.x - ship.size / 2 &&
          a.x < ship.x + ship.size / 2 &&
          a.y + a.size > ship.y - ship.size / 2 &&
          a.y - a.size < ship.y + ship.size / 2
        ) {
          gameOver = true;
        }
      }
    }

    function spawnAsteroid() {
      let size = Math.random() * 20 + 10;
      let x = Math.random() * (canvas.width - size * 2) + size;
      let y = -size;
      let speed = Math.random() * 3 + 2;
      asteroids.push({ x, y, size, speed });
    }

    function drawScore() {
      ctx.fillStyle = "white";
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + score, 10, 30);
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!gameOver) {
        drawShip();
        drawAsteroids();
        updateAsteroids();
        drawScore();
        requestAnimationFrame(gameLoop);
      } else {
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.fillText("Game Over!", canvas.width / 2 - 100, canvas.height / 2);
        ctx.font = "20px Arial";
        ctx.fillText("Final Score: " + score, canvas.width / 2 - 60, canvas.height / 2 + 30);
      }
    }

    // Touch controls
    document.addEventListener("touchmove", (e) => {
      let touch = e.touches[0];
      ship.x = touch.clientX;
    });

    // Spawn asteroids periodically
    setInterval(spawnAsteroid, 700);

    gameLoop();
  </script>
</body>
</html>
function spawnAsteroid() { const size = 12 + Math.random()36; const x = Math.random()(canvas.width - size) + size/2; const vy = 1.2 + Math.random()*(speed + 1); asteroids.push({ x, y: -size, r: size/2, vy, rot: Math.random()*Math.PI }); } function resetGame() { asteroids = []; spawnTimer = 0; frames = 0; over = false; score = 0; } function startGame() { resetGame(); running = true; requestAnimationFrame(loop); } function stopGame() { running = false; }

function update() { frames++; if (moveLeft) playerX -= speed; if (moveRight) playerX += speed; playerX = Math.max(playerW/2, Math.min(canvas.width - playerW/2, playerX)); spawnTimer++; if (spawnTimer >= spawnInterval) { spawnAsteroid(); spawnTimer = 0; } for (let i = asteroids.length - 1; i >= 0; i--) { let a = asteroids[i]; a.y += a.vy; a.rot += 0.02; if (a.y - a.r > canvas.height) { asteroids.splice(i,1); score++; } } for (const a of asteroids) { const closestX = Math.max(playerX - playerW/2, Math.min(a.x, playerX + playerW/2)); const closestY = Math.max(playerY - playerH/2, Math.min(a.y, playerY + playerH/2)); const dx = a.x - closestX, dy = a.y - closestY; if (dxdx + dydy < a.r * a.r) over = true; } } function draw() { ctx.fillStyle = '#050814'; ctx.fillRect(0,0,canvas.width,canvas.height); for (let i=0;i<80;i++){ const x = (i * 97) % canvas.width; const y = ((i53) + (frames % canvas.height)) % canvas.height; ctx.fillStyle = i%17===0 ? '#FFF' : '#7f8fa6'; ctx.fillRect(x, y, 1,1); } ctx.save(); ctx.translate(playerX, playerY); ctx.fillStyle = '#ffd166'; ctx.beginPath(); ctx.moveTo(0, -playerH/2); ctx.lineTo(-playerW/2, playerH/2); ctx.lineTo(playerW/2, playerH/2); ctx.closePath(); ctx.fill(); ctx.restore(); for (const a of asteroids) { ctx.save(); ctx.translate(a.x, a.y); ctx.rotate(a.rot); ctx.beginPath(); for (let i=0;i<6;i++){ const ang = (i/6) * Math.PI2; const rad = a.r * (0.7 + Math.random()*0.6); const x = Math.cos(ang) * rad, y = Math.sin(ang) * rad; if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); ctx.fillStyle = '#6b6b6b'; ctx.fill(); ctx.restore(); } ctx.fillStyle = 'white'; ctx.fillText('Score: ' + score, 12, 22); ctx.fillText('High: ' + highScore, 12, 42); } function loop() { if (!over) { update(); draw(); requestAnimationFrame(loop); } else { running = false; if (score > highScore) { highScore = score; localStorage.setItem('astro_high', highScore); } ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(canvas.width/2 - 160, canvas.height/2 - 70, 320, 140); ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.font = '20px Arial'; ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 20); ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2 + 4); ctx.fillText('High: ' + highScore, canvas.width/2, canvas.height/2 + 32); ctx.textAlign = 'left'; } } </script>

</body>
</html>
